package main.java.mazerunner.engine;

import main.java.mazerunner.mazegenerator.MazeGenerator;
import main.java.mazerunner.model.Directions;
import main.java.mazerunner.model.GameObject;
import main.java.mazerunner.model.Player;
import main.java.mazerunner.model.Position;

import java.util.ArrayList;
import java.util.Collections;

import static main.java.mazerunner.mazegenerator.MazeGenerator.EMPTY_SPACE;

/**
 * A class to show the maze with game objects such as gold and end point.
 */
public class GameGrid {

    private final int height;
    private final int width;

    private char[][] grids;
    private ArrayList<Integer> random_X;
    private ArrayList<Integer> random_Y;

    /**
     * @param mazeHeight the number of rows of the maze defined by the player
     * @param mazeWidth  the number of columns of the maze defined by the player
     */
    public GameGrid(int mazeHeight, int mazeWidth) {
        this.grids = new MazeGenerator(mazeHeight, mazeWidth).generate();
        this.height = grids.length;
        this.width = grids[0].length;
        randomize_X();
        randomize_Y();
    }

    /**
     * Adds the character of the specified {@link GameObject} to the game map at its position.
     *
     * @param object the game object to be added
     */
    public Position add2Grids(GameObject object) {
        Position added = new Position(-1,-1);
        grids[object.getY()][object.getX()] = object.getCharacter();
        added = object.getPosition();
        return added;
    }

    /**
     * Removes the icon character of the specified {@link GameObject} from the game map at its position.
     *
     * @param object the game object to be removed
     */
    public Position removeFromGrids(GameObject object) {
        Position removed = new Position(-1, -1);
        grids[object.getY()][object.getX()] = EMPTY_SPACE;
        removed = object.getPosition();
        return removed;
    }

    /**
     * Returns a {@link Position} object generated by using the random x and y coordinates.
     * The result is passed to the constructor while creating {@link GameObject} so that we can have our
     * game objects scattered randomly on the game map for each new game.
     *
     * @return a Position object with random x and y coordinates
     */
    public Position getRandomPosition() {
        return new Position(random_X.remove(0), random_Y.remove(0));
    }

    /**
     * Returns <code>true</code> if the specified direction the specified Player is trying to move is valid.
     * A valid movement is not blocked by any walls. The validity is determined by checking
     * if the character in the movement's direction is a 'space' that represents 'no wall'.
     *
     * @param player    the Player object
     * @param direction the direction to move
     * @return <code>true</code> if the movement is valid, <code>false</code> otherwise
     */
    public boolean validateMovement(Player player, String direction) {
        switch (direction) {
            case Directions.DIRECTION_UP:
                return (player.getY() > 1 && this.grids[player.getY() - 1][player.getX()] == EMPTY_SPACE);
            case Directions.DIRECTION_DOWN:
                return (player.getY() < height - 2 && this.grids[player.getY() + 1][player.getX()] == EMPTY_SPACE);
            case Directions.DIRECTION_LEFT:
                return (player.getX() > 2 && this.grids[player.getY()][player.getX() - 2] == EMPTY_SPACE);
            case Directions.DIRECTION_RIGHT:
                return (player.getX() < width - 3 && this.grids[player.getY()][player.getX() + 2] == EMPTY_SPACE);
            default:
                return false;
        }
    }

    /**
     * Generates a list of random x-coordinates for getting randomize position
     */
    private void randomize_X() {
        this.random_X = new ArrayList<>();
        for (int i = 2; i < this.width; i += 4) this.random_X.add(i);
        Collections.shuffle(this.random_X);
    }

    /**
     * Generates a list of random y-coordinates for getting randomize position
     */
    private void randomize_Y() {
        this.random_Y = new ArrayList<>();
        for (int i = 1; i < this.height; i += 2) this.random_Y.add(i);
        Collections.shuffle(this.random_Y);
    }

    /**
     * getter and setters
     */
    public char[][] getGrids() {
        return grids;
    }

    public int getWidth() {
        return this.width;
    }

    public int getHeight() {
        return this.height;
    }
}
